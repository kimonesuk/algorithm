# 파이썬 SW 문제해결 기본 - List 1

## 목차(Index)
- [1. 완전검색(Exhaustive Search)](#1-완전검색-exhaustive-search)
- [2. 탐욕 알고리즘(Greedy Algorithm)](#2-탐욕-알고리즘)
- [3. 정렬(Sort)](#3-정렬)
  - [1. 정렬 개요](#1.-정렬-개요)
  - [2. 버블 정렬](#2.-버블-정렬)
  - [3. 카운팅 정렬](#3.-카운팅-정렬)
- [4. 연습문제](#4-연습문제)
- [BACK](https://github.com/kimonesuk/algorithm/blob/main/README.md)

## 1 완전검색 Exhaustive Search

* = Brute-force, Generate-and-Test
* 모든 경우의 수를 테스트한 후, 최종 해법을 도출
* 모든 경우의 수를 생성하고 테스트하기 떄문에 수행 속도는 느리지만, 해답을 찾아내지 못할 확률은 작음
* 주어진 문제를 풀 떄, 우선 완점 검색으로 접근하여 해답을 도출한 후, 성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확인하는 것이 바람직함
* 예시) Baby-gin 게임
	- 0~9 사이의 숫자 카드에서 임의의 카드 6장을 뽑았을 때, 3장의 카드가 연속적인 경우 run, 3장의 카드가 동일한 번호를 갖는 경우를 triple이라고 함
	- 6장의 카드가 run과 triple로만 구성된 경우를 Baby-gin이라 부름
		+ 666,777 : 두 개의 triplete : Baby-gin
		+ 054060 : 한 개의 run, 한 개의 triplete : Baby-gin
		+ 101123 : 한 개의 triplet, 023 : Baby-gin 아님
	- 완전검색기법
		1. 고려할 수 있는 모든 경우의 수 생성(중복 포함)
		2. 해답 테스트하기 : 앞 3자리와 뒤 3자리를 잘라, run과 triplete 여부를 테스트하고 최종적으로 Baby-gin을 판단

## 2 탐욕 알고리즘

* 여러 경우 중 하나를 결정해야 할 때마다 **그 순간에 최적이라고 생각되는 것을 선택해나가는 방식**으로 진행하여 최종적인 해답에 도달
* 각 선택의 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그것들을 수집한 최종해답이 최적이라는 보장은 없음
* 탐욕 알고리즘의 수행 과정
	1. 해 선택 : 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분 해 집합에 추가함
	2. 실행 가능성 검사 : 새로운 부분해 집합이 실행 가능한지 확인, 문제의 제약 조건을 위반하지 않는지를 검사
	3. 해 검사 : 새로운 부분 해 집합이 문제의 해가 되는지를 확인, 아직 전체 문제의 해가 완성되지 않았다면 해 선택부터 다시 시작함
* 예시) 거스름돈 줄이기 : 어떻게 하면 손님에게 거스름돈으로 주는 지폐와 동전의 개수를 최소한으로 할 수 있는가?
	- 해 선택 : 가장 단위가 큰 동전을 하나 골라 거스름돈에 추가
	- 실행 가능성 검사 : 거스름돈이 손님에게 내드려야 할 액수를 초과하는지 확인, 초과한다면 마지막에 추가한 동전을 거스름돈에서 빼고, 해 선택으로 돌아가서 현재보다 한 단계 작은 단위의 동전을 추가
	- 해 검사 : 거스름돈이 손님에게 내드려야 하는 액수와 일치하는지 확인, 액수에 모자라면 다시 해 선택으로 돌아가서 거스름돈에 추가할 동전을 고름
* 예시) Baby-gin
	- 6개의 숫자는 6자리의 정수 값으로 입력
	- COUNTS 리스트의 각 원소를 체크하여 run과 triplete 및 Baby-gin 여부를 판단함
		+ 탐욕 알고리즘을 적용
		+ COUNTS 리스트에서 run과 triplete 중에 가능한것을 조사
		+ 조사에 사용한 데이터는 삭제
		+ 남은 데이터를 다시 run과 triplete 중에 가능한지 조사
	- 해답을 찾지 못하는 경우 : 입력 받은 숫자를 정렬한 후, 앞뒤 3자리씩 끊어서 run 및 triplete 확인하는 방법
		+ {6, 4, 4, 5, 4, 4} : 가능
		+ {1, 2, 3, 1, 2, 3} : 실패

## 3 정렬
### 1. 정렬 개요
* 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값(오름차순, ascending) 혹은 그 반대의 순서(내림차순, descending)로 재배열하는 것
* 키(key)란 자료를 정렬하는 기준이 되는 특정 값
* 예시) 버블정렬, 카운팅정렬, 선택정렬, 퀵정렬, 삽입정렬, 병합정렬

### 2. 버블 정렬
* 인접한 두개의 원소를 비교하며 자리를 계속 교환하는 방식
* 비교와 교환
* 정렬 과정
	1. 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동
	2. 한 단계가 끝나면 가장 큰 원소 또는 가장 작은 원소가 마지막 자리로 정렬
* 교환하며 자리를 이동하는 모습이 물 위에 올라오는 거품모양 같아서 버블정렬이라고 함
* 시간 복잡도 = O(n^2)
* 예시) {55, 7, 78, 12, 42}
	1. 회
        + 55/7/78/12/42
        + 7/55/78/12/42
        + 7/55/12/78/42
        + 7/55/12/42/78
	2. 회
		+ 7/55/12/42/78
		+ 7/12/55/42/78
		+ 7/12/42/55/78
	3. ... 5회에 끝

### 3. 카운팅 정렬
* 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하며, 선형 시간에 정렬하는 효율적인 알고리즘
* 비교환 방식
* 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능 - 각 항목의 발생 회수를 기록하기 위해, 정수 항목으로 인덱스되는 카운트들의 리스트를 사용하기 때문
* 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야함
* n이 비교적 작을 때만 가능
* 시간 복잡도 = O(n + k) : n은 리스트의 개수, k는 정수의 최대값
* 예시) {0, 4, 1, 3, 1, 2, 4, 1}
	1. 데이터에서 각 항목들의 발생 회수를 세고, 정수 항목들로 직접 인덱스 되는 카운트 리스트 Counts에 저장
	COUNTS = {1, 3, 1, 1, 2}
	2. 정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수에 반영하기 위해 Counts의 원소를 조정
	COUNTS = {1, 4, 5, 6, 8}
	3. 마지막부터 값을 순서에 맞게 넣어줌 : 해당 값의 COUNTS 값에 해당하는 위치에 넣어주고 COUNTS 1 감소

## 4 연습문제
* [min_max](https://github.com/kimonesuk/algorithm/blob/main/list_minmax.ipynb)
* 전기버스
* 숫자카드
* 구간합

