# 파이썬 SW 문제해결 기본 - List 2

**목차(Index)**
- [파이썬 SW 문제해결 기본 - List 2](#파이썬-sw-문제해결-기본---list-2)
	- [2차원 리스트](#2차원-리스트)
		- [2차원 리스트 구조](#2차원-리스트-구조)
		- [리스트 초기화](#리스트-초기화)
		- [2차원 리스트에서 원하는 데이터의 위치 찾기](#2차원-리스트에서-원하는-데이터의-위치-찾기)
		- [리스트 순회](#리스트-순회)
			- [행 우선 순회](#행-우선-순회)
			- [열 우선 순회](#열-우선-순회)
			- [지그재그 순회](#지그재그-순회)
		- [델타를 이용한 2차 리스트 탐색](#델타를-이용한-2차-리스트-탐색)
		- [전치 행렬](#전치-행렬)
	- [부분 집합 - 부분 집합의 합 문제](#부분-집합---부분-집합의-합-문제)
	- [검색](#검색)
		- [검색 개요](#검색-개요)
		- [순차 검색](#순차-검색)
			- [정렬되지 않은 자료의 검색 과정](#정렬되지-않은-자료의-검색-과정)
			- [정렬된 자료의 검색 과정](#정렬된-자료의-검색-과정)
		- [이진검색](#이진검색)
			- [이진 검색의 과정](#이진-검색의-과정)
		- [인덱스](#인덱스)
	- [정렬](#정렬)
		- [셀렉션 알고리즘](#셀렉션-알고리즘)
			- [셀렉션 선택 과정](#셀렉션-선택-과정)
		- [선택 정렬](#선택-정렬)
			- [정렬 과정](#정렬-과정)
	- [알고리즘 비교](#알고리즘-비교)
	- [연습문제](#연습문제)

## 2차원 리스트
### 2차원 리스트 구조
* 1차원 리스트를 묶어놓은 리스트
* 2차원 이상의 다차원 리스트는 차원에 따라 index를 선언
### 리스트 초기화
``` python
arr = [0, 0, 0, 0, 0]
arr = [0] * 5 # [0, 0, 0, 0, 0]
arr = [i for i in range(2, 9) if i % 2 == 0] # [2, 4, 6, 8]

brr = [[1, 2, 3], [1, 2, 3], [1, 2, 3]]
brr = [[1, 2, 3]] * 3
brr = [[1, 2, 3] for i in range(3)]
brr = [[i, j] for i in range(3) for j in range(2)] # [[0,0], [0,1], [1,0], [1,1], [2,0], [2,1]]
```
### 2차원 리스트에서 원하는 데이터의 위치 찾기
``` python
n, m = map(int, input().split())
mylist = [list(map(int, input().split())) for _ in range(n)]
newlist = [(i,j) for i in range(n) for j in range(m) if mylist[i][j] == 1]
```
### 리스트 순회
* N\*M 리스트의 N\*M개의 모든 원소를 빠짐없이 조사하는 방법   
#### 행 우선 순회
``` python
for i in range(len(arr)):
	for j in range(len(arr[i])):
		arr[i][j]
```
#### 열 우선 순회
``` python
for j in range(len(arr[0])):
	for i in range(len(arr)):
		arr[i][j]
```
#### 지그재그 순회
``` python
for i in range(len(arr)):
	for j in range(len(arr[0])):
		arr[i][j + (m-1-2*j)*(i%2)]
```
### 델타를 이용한 2차 리스트 탐색
* 2차 리스트의 한 좌표에서 네 방향의 인접 리스트 요소를 탐색할 때 사용하는 방법
* 델타 값은 한 좌표에서 네 방향의 좌표와 x, y의 차이를 저장한 리스트로 구현
* 델타 값을 이용하여 특정 원소의 상하좌우에 위치한 원소에 접근할 수 있음
	* 이차원 리스트의 가장자리 원소들은 상하좌우 네 방향에 원소가 존재하지 않을 경우가 있으므로, index를 체크하거나 index의 범위를 제한해야 함
``` python
arr[0 ... n-1][0 ... n-1]
dx = [0, 0, -1, 1] # 상하좌우
dy = [-1, -1, 0, 0]

for x in range(len(arr)):
	for y in range(len(arr[x])):
		for i in range(4):
			testX = x + dx[i]
			testY = y + dy[i]
			print(arr[testX][testY])
```
### 전치 행렬
* 행과 열의 값이 반대인 행렬
``` python
arr = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
for i in range(3):
	for j in range(3):
		if i < j:
			arr[i][j], arr[j][i] = arr[j][i], arr[i][j]
```
* zip(iterable *) : 동일한 개수로 이루어진 자료형들을 묶어 주는 역할을 하는 함수
``` python
alpha = ['a', 'b', 'c']
indxe = [1, 2, 3]
alpha_index = list(zip(alpha, index))
print(alpha_index) # [('a', 1), ('b', 2), ('c', 3)]

arr = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
print(list(zip(*arr))) # [(1, 4, 7), (2, 5, 8), (3, 6, 9)]
#*arr = 행렬을 열단위로 분해, zip(*matrix) : 전치행렬
```

## 부분 집합 - 부분 집합의 합 문제
* 유한 개의 정수로 이루어진 집합이 있을 때, 이 집합의 부분 집합 중에서 그 집합의 원소를 모두 더한 값이 0이 되는 경우가 있는지를 알아내는 문제
* (예시) {-7, -3, -2, 5, 8} => {-3, -2, 5}
	1. 완전 검색기법으로 부분 집합 합 문제를 풀기 위해서는 우선 집합의 모든 부분 집합을 생성한 후 각 부분 집합의 합을 계산
	2. 모든 부분 집합을 생성하는 방법
``` python
bit = [0, 0, 0, 0]
for i in range(2):
	bit[0] = i
	for j in range(2):
		bit[1] = j
		for k in range(2):
			bit[2] = k
			for l in range(2):
				bit[3] = l
				print(bit) # 생성된 부분집합 출력
```
* 비트 연산자 : 0과 1로 이루어진 이진수에 대한 연산을 수행하는 연산자
	* 종류
    	* & : 비트 단위로 AND 연산을 함
    	* | : 비트 단위로 OR 연산을 함
    	* << : 피연산자의 비트 열을 왼쪽으로 이동시킴
    	* \>> : 피연산자의 비트 열을 오른쪽으로 이동시킴
  	* 예시
    	* `1 << n : 2^n` : 원소가 n개일 경우의 모든 부분 집합의 수
    	* `i & (1<<j) : 1` : i에서 j번째 비트가 1인지 아닌지를 리턴함
* 간결하게 부분 집합을 생성하는 방법
``` python
arr = [3, 6, 7, 1, 5, 4]
n = len(arr)
for i in range(1<<n): # 1<<n : 부분 집합의 개수만큼 반복 : 비트로 표현 > 포함(1/0)여부
	for j in range(n): # 원소의 수만큼 비트를 비교함
		if i&(1<<j): # i의 j번째 비트가 1이면 j번째 원소 출력
			print(arr[j], end=",")
	print() # 개행
```
   
## 검색
### 검색 개요
* 저장되어 있는 자료 중에서 **원하는 항목**을 찾는 작업
  * 원하는 항목 : 목적하는 **탐색키**를 가진 항목
  * 탐색키 : 자료를 구별하여 인식할 수 있는 키
* 종류
  * 순차 검색
  * 이진 검색
  * 인덱싱
### 순차 검색
* 일렬로 되어 있는 자료를 **순서대로 검색**하는 방법
* 리스트나 연결리스트 등 순차구조로 구현된 자료구조에서 유용
* 구현이 쉽지만, 검색 대상이 많은 경우 수행시간의 증가로 비효율적임
#### 정렬되지 않은 자료의 검색 과정
* 첫번째 원소부터 순서대로 검색대상과 키 값이 같은 원소가 있는지를 비교하여 찾음
* 키 값이 동일한 원소를 찾으면 그 원소의 인덱스를 반환
* 자료구조의 마지막에 갈 때까지 검색 대상을 찾지 못하면 검색 실패
* (예시) 2를 검색하는 경우
[4, 9, 11, 23, 2, 19, 7]
  1. 4 != 2, 9, 11, 23, 2, 19, 7
  2. 4, 9 != 2, 11, 23, 2, 19, 7
  3. ...
  4. 4, 9, 11, 23, 2 == 2, 19, 7
* 정렬되지 않은 자료에서의 순차 검색의 평균 비교 횟수 : 1/n(1+2+3+...+n) = (n+1)/2
* 시간 복잡도 : O(n)
``` python
def sequentialSearch(a, n ,key):
	i = 0
	while i < n and a[i] != key:
		i = i + 1
	if i < n : return i
	else : return -1
```
#### 정렬된 자료의 검색 과정
* 자료가 오름차순으로 정렬된 상태에서 검색한다고 가정
* 자료를 순차적으로 검색하면서 키 값을 비교함
* 원소의 키 값이 검색 대상의 키 값보다 크면 원소가 없다는 것이므로 더 이상 검색하지 않고 검색을 종료함
* (예시) 10을 검색하는 경우
[2, 4, 7, 9, 11, 19, 23]
  1. 2 < 10, 4, 7, 9, 11, 19, 23
  2. 2, 4 < 10, 7, 9, 11, 19, 23
  3. ...
  4. 2, 4, 7, 9, 11>10, 19, 23 (검색종료)
* 정렬되어 있으므로, 검색 실패를 반환하는 경우 평균 비교 회수가 반으로 줄어듬
* 시간 복잡도 : O(n)
``` python
def sequentialSearch(a, n ,key):
	i = 0
	while i < n and a[i] < key:
		i = i + 1
	if i < n and a[i] == key : return i
	else : return -1
```
### 이진검색
* 자료의 가운데 항목의 키 값과 비교하여 다음 검색의 위치를 결정하고 검색을 계속하는 방법
* 목적 키를 찾을 때까지 이진 검색을 순환적으로 반복 수행함으로써 **검색 범위를 반으로 줄여가며 빠르게 검색**을 수행함
* 이진 검색을 하기 위해서는 **자료가 정렬된 상태**여야 함
* 정렬된 데이터 n개가 있는 경우의 시간 복잡도 : O(logn)
#### 이진 검색의 과정
* 자료의 중앙에 있는 원소를 선택
* 중앙 원소의 값과 찾고자 하는 목표 값을 비교
* 목표값 < 중앙 원소 값 : 자료의 왼쪽 반에 대해서 새로 검색을 수행
* 목표값 > 중앙 원소 값 : 자료의 오른쪽 반에 대해서 새로 검색을 수행
* 찾고자 하는 값을 찾을 때까지 앞의 과정을 반복
* (예시) 7을 검색하는 경우
[2, 4, 7, 9, 11, 19, 23]
  1. 2, 4, 7, **9(중앙)**, 11, 19, 23
  2. 2, **4(중앙)**, 7, 11, 19, 23
  3. 2, 4, **7(검색완료)**, 11, 19, 23
``` python
def binarySearch(a, key):
	start = 0
	end = len(a) - 1
	while start <= end:
		middle = start + (end - start)//2
		if key == a[middle]: # 검색 성공
			return True
		elif key < a[middle]:
			end = middle - 1
		else:
			start = middle + 1
	return False

def binarySearch(a, low, high, key): # 재귀함수 이용
	if low > high: # 검색 실패
		return False
	else:
		middle = (low + high)//2
		if key == a[middle]:
			return True
		elif key < a[middle]:
			return binarySearch(a, low, middle-1, key)
		elif a[middle] < key:
			return binarySearch(a, middle+1, high, key)
```
### 인덱스
* 데이터베이스에서 유래, 테이블에 대한 동작 속도를 높임
* 룩 업 데이블(LookUpTable)등의 용어로 사용
* 인덱스를 저장하는데 필요한 디스크 공간은 보통 테이블 저장에 필요한 디스크 공간보다 작음
  * 인덱스는 키-필드만 가지고 있고, 테이블의 다른 항목은 가지고 있지 않음
* 리스트를 이용한 인덱스
  * 대량의 데이터를 매번 정렬하면, 프로그램의 반응은 느려질 수 밖에 없음. 이러한 대량 데이터의 성능 저하 문제를 해결하기 위해 리스트인덱스를 사용함

## 정렬
### 셀렉션 알고리즘
* 저장되어 있는 자료로부터 k번째로 큰/작은 원소를 찾는 방법
* 최소값, 최대값, 중간값을 찾는 알고리즘
#### 셀렉션 선택 과정
* 정렬 알고리즘을 이용하여 자료 정렬
* 원하는 순서에 있는 원소 가져오기
### 선택 정렬
* 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치를 교환하는 방식
* 셀렉션 알고리즘을 전체 자료에 적용한 것
#### 정렬 과정
* 주어진 리스트 중에서 최소값을 찾음
* 그 값을 리스트의 맨 앞에 위치한 값과 교환
* 맨 처음 위치를 제외한 나머지 리스트를 대상으로 위의 과정을 반복
* 시간 복잡도 : O(n^2)
* (예시)
[65, 25, 10, 22, 11]
  1. 리스트에서 최소값 검색 : 10
  2. 리스트의 맨 앞에 위치한 값과 교환 [10, 25, 64, 22, 11]
  3. 반복
``` python
def selectionSort(a):
	for i in range(0, len(a) - 1):
		min = i
		for j in range(i + 1, len(a)):
			if a[min] > a[j]:
				min = j
			a[i], a[min] = a[min], a[i]
```
## 알고리즘 비교
|알고리즘|평균수행시간|최악수행시간|알고리즘 기법|비고|
|:--:|:--:|:--:|:--:|:--:|
|버블 정렬|O(${n^2}$)|O(${n^2}$)|비교와 교환|코딩이 가장 손쉬움|
|카운팅 정렬|O(n+k)|O(${n^2}$)|비교환 방식|n이 비교적 작을때만 가능|
|**선택 정렬**|O(${n^2}$)|O(${n^2}$)|비교와 교환|교환의 회수가 버블, 삽입정렬보다 작음|
|퀵 정렬|O(${nlogn}$)|O(${n^2}$)|분할 정복|최악의 경우 O(${n^2}$)이지만, 평균적으로는 가장 빠름|
|삽입 정렬|O(${n^2}$)|O(${n^2}$)|비교와 교환|n의 개수가 작을 때 효과적|
|병합 정렬|O(${nlogn}$)|O(${nlogn}$)|분할 정복|연결 리스트의 경우 가장 효율적인 방식|
   
## 연습문제
* [색칠하기](https://github.com/kimonesuk/algorithm/blob/main/list_paint.ipynb)
* [부분집합의 합](https://github.com/kimonesuk/algorithm/blob/main/list_subset.ipynb)
* [이진탐색](https://github.com/kimonesuk/algorithm/blob/main/list_bisearch.ipynb)
* [특별한 정렬](https://github.com/kimonesuk/algorithm/blob/main/list_special.ipynb)